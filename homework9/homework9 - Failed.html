<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 9 - Failed</title>

    <link rel="stylesheet" href="../css/bootstrap.min.css">

    <script src="../js/jquery-3.5.1.min.js" type="text/javascript"></script>
    <script src="../js/bootstrap.min.js" type="text/javascript"></script>
    <script src="../GLjs/gl-matrix-min.js" type="text/javascript"></script>
    <style>
        body{
            overflow: hidden;
        }

        .Info-card{
            position: absolute;
            width: 40%;
            height: 440px;
            color: white;
            background: rgba(0.2, 0.2, 0.2, 0.8);
            border-radius: 30px;
            letter-spacing: 1.5px;
            line-height: 1.4rem;
            font-family: "微軟正黑體";
            bottom: -100px;
            right: 0;
            font-size: 0.8rem;
            z-index: 900;
            transition: all 400ms ease-out;
        }

        .Info-card.hide{
            bottom: -398px;
        }

        .switch-box{
            width: 100%;
            height: 40px;
            background-color: rgb(126 65 255);
            border-radius: 15px;
            z-index: 1000;
            padding: 9px 15px;
            text-align: right;
            font-size: 1.2rem;
            padding-right: 25px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 200ms ease-in-out;
        }

        .switch-box:hover{
            background-color: rgb(123 179 243);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="d-flex vh-100 justify-content-center align-items-center">
        <canvas id="testing" style="border: none;"></canvas>
        <div class="Info-card">
            <div class="switch-box">
                Off
            </div>
            <div class="row">                
                <div class="col-md-12 text-center">
                    <p>
                        L 切換光照模型，目前是：<span id="lightingModel"></span> <br/>
                        F 開 / 關 XYZ 軸，G 顯示 / 隱藏 軌道 <br/>
                        W / S / A / D 可以移動攝影機；滑鼠移動視角 <br/>
                        C / V 可以 降低 / 提高 轉速 <br/>
                    </p>
                </div>
                <div class="col-md-12 mb-2 text-center">
                    地球公轉: <span id="years">0</span>, 月亮公轉: <span id="months">0</span>, 地球自轉: <span id="days">0</span>, 目前轉速：<span id="speed"></span> <br/>
                    camera.position: (<span id="positionX">0</span>, <span id="positionY">0</span>, <span id="positionZ">0</span>) <br/>
                    camera.yaw(X): <span id="yaw">0</span> degree , camera.pitch(Y): <span id="pitch">0</span> degree<br/>
                    camera.direction: (<span id="directionX">0</span>, <span id="directionY">0</span>, <span id="directionZ">0</span>), Facing: <span id="facing">North</span> <br/>
                    camera.right: (<span id="rightX">0</span>, <span id="righty">0</span>, <span id="rightZ">0</span>) <br/>
                    camera.up: (<span id="upX">0</span>, <span id="upY">0</span>, <span id="upZ">0</span>) <br/>
                </div>
                <div class="col-md-12 text-center">
                    <small>Made by 10957037 張竣傑</small>
                </div>
            </div>
        </div>
    </div>

    <script id="vertex" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 model;
        uniform mat4 view;
        uniform mat4 projection;
        uniform mat3 normalModel;
        uniform bool isCubeMap;
        
        varying vec3 navPos;
        varying vec3 FragPos;
        varying vec3 Normal;
        varying vec2 textureCoord;
        
        void main(void) {
            
            navPos = aVertexPosition;
            FragPos = vec3(model * vec4(aVertexPosition, 1.0));
            Normal = normalModel * aNormal;
            textureCoord = aTextureCoord;

            if(isCubeMap){
                // 繪製天空盒，將取消攝影機矩陣的位移，如此一來天空盒就可以無窮遠。
                mat4 view_new = mat4(mat3(view));
                vec4 pos = projection * view_new * vec4(FragPos, 1.0);
                gl_Position = pos.xyww;
            }else{
                gl_Position = projection * view * vec4(FragPos, 1.0);
            }
        }
    </script>
    <script id="fragment" type="x-shader/x-fragment">
        precision mediump float;

        struct Material {
            sampler2D diffuse;
            sampler2D specular;
            float shininess;
        };

        struct Light {
            vec3 position;

            vec3 ambient;
            vec3 diffuse;
            vec3 specular;

            float constant;
            float linear;
            float quadratic;
        };

        varying vec3 navPos;
        varying vec3 FragPos;
        varying vec3 Normal;
        varying vec2 textureCoord;

        uniform bool isRenderingSun;
        uniform bool isRenderingSpace;
        uniform bool enableTexture;
        uniform vec3 color;
        uniform vec3 viewPos;
        uniform Material material;
        uniform Light light;
        uniform int currentLighting;
        
        uniform bool isCubeMap;
        uniform samplerCube skybox;

        mat3 cotangentFrame(vec3 N, vec3 p, vec2 uv){
            vec3 dp1 = dFdx(p);
            vec3 dp2 = dFdy(p);
            vec2 duv1 = dFdx(uv);
            vec2 duv2 = dFdy(uv);

            vec3 dp2perp = cross(dp2, N);
            vec3 dp1perp = cross(N, dp1);
            vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
            vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

            float invmax = inversesqrt(max(dot(T, T), dot(B, B)));
            return mat3(T * invmax, B * invmax, N );
        }

    	void main(void) {

            vec4 texture_diffuse;
            vec4 texture_specular;

            if(isCubeMap){
                // 材質類型採用 cubemap
                texture_diffuse = textureCube(skybox, normalize(navPos));
                texture_specular = textureCube(skybox, normalize(navPos));
            }else {
                // 材質類型採用 texture2D
                texture_diffuse = texture2D(material.diffuse, textureCoord);
                texture_specular = texture2D(material.specular, textureCoord);
            }
            
            if(isRenderingSun && enableTexture){

                // 繪製太陽
                vec3 result = vec3(0.0, 0.0, 0.0);
                if(currentLighting == 1 || currentLighting == 2){
                    vec3 texture_map = texture_diffuse.rgb;
                    vec3 emission = texture_diffuse.rgb;
                    emission *= 0.5;
                    result = texture_map + emission;
                }else{
                    result = texture_diffuse.rgb;
                }
                gl_FragColor = vec4(result, 1.0);

            } else if (enableTexture) {

                vec3 result = vec3(0.0, 0.0, 0.0);

                // 有開啟材質選項
                vec4 temp = texture_diffuse;
                if(temp.a < 0.1) {
                    discard;
                }

                // 代表使用 Phong 或 Blinn-Phong 光照
                if(currentLighting == 1 || currentLighting == 2){
                    // 環境光
                    vec3 ambient = light.ambient * temp.rgb;

                    // 漫射
                    vec3 norm = normalize(Normal);
                    vec3 lightDir = normalize(light.position - FragPos);
                    float diff = max(dot(norm, lightDir), 0.0);
                    vec3 diffuse = light.diffuse * diff * temp.rgb;

                    // 高光
                    vec3 viewDir = normalize(viewPos - FragPos);
                    float spec = 0.0;
                    if(currentLighting == 2){
                        // 代表使用 Blinn-Phong 光照
                        vec3 halfway = normalize(lightDir + viewDir);
                        spec = pow(max(dot(norm, halfway), 0.0), material.shininess);
                    }else{
                        vec3 reflectDir = reflect(-lightDir, norm);
                        spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);

                    }
                    vec3 specular = light.specular * spec * texture_specular.rgb;

                    // 光衰弱
                    float distance = length(light.position - FragPos);
                    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));
                
                    if(!isRenderingSpace){
                        ambient *= attenuation;
                        diffuse *= attenuation;
                        specular *= attenuation;
                    }else{
                        ambient *= 10.0;
                        diffuse *= 10.0;
                        specular *= 0.0;
                    }
                    result = ambient + diffuse + specular;
                }else{
                    // 不使用光照
                    result = temp.rgb;
                }
                gl_FragColor = vec4(result, temp.a);
            } else {
                gl_FragColor = vec4(color, 1.0);
            }
        }
    </script>

    <script type="text/javascript">
        $(function() {
            window['mat4'] = glMatrix.mat4;
            window['mat3'] = glMatrix.mat3;
            window['vec3'] = glMatrix.vec3;
            window['vec4'] = glMatrix.vec4;

            let gl;

            let cube = {};
            let sphere = {};

            // 重力常數
            let G = 6.673e-11;

            // 物件比例尺與各參數設定:
            let space = {
                "type": "universe",
                "diameter": 10000,
                "AU": NaN,
                "obliquity": -45,
                "orbital_period": NaN,
                "rotate_period": 5000,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
            };
            let sun = {
                "type": "star",
                "diameter": 1392700,
                "AU": NaN,
                "position": vec3.set(vec3.create(), 0, 0, 0),
                "obliquity": 7.25,
                "orbital_period": NaN,
                "rotate_period": 25.379995,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "mass": 1.989,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
            };
            let mercury = {
                "type": "planet",
                "diameter": 4879,
                "AU": 0.4 * 200 + 40,
                "obliquity": 0,
                "orbital_period": 87.9691,
                "rotate_period": 58.6462,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 0.38700 * 200 + 40,
                    "semi_minor": 0.37870 * 200 + 40,
                    "eccentricity": 0.205995344,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let venus = {
                "type": "planet",
                "diameter": 12104,
                "AU": 0.72 * 200 + 40,
                "obliquity": 177.36,
                "orbital_period": 224.701,
                "rotate_period": 243.0187,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 0.72300 * 200 + 40,
                    "semi_minor": 0.72298 * 200 + 40,
                    "eccentricity": 0.007438029,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let earth = {
                "type": "planet",
                "diameter": 12742,
                "AU": 1 * 200 + 40,
                "position": vec3.set(vec3.create(), 240, 0, 0),
                "obliquity": 23.4,
                "orbital_period": 365.25636,
                "rotate_period": 1,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "mass": 5.972e24,
                "perihelion": 0.9832,
                "velocity": vec3.set(vec3.create(), 0, 0, 200),
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 1 * 200 + 40,
                    "semi_minor": 0.99986 * 200 + 40,
                    "eccentricity": 0.016732615,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let moon = {
                "type": "satellite",
                "diameter": 3474,
                "AU": 3.84400 * 4,
                "obliquity": 6.68,
                "orbital_period": 27.32,
                "rotate_period": 27.32,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 3.84400 * 4,
                    "semi_minor": 3.84400 * 4,
                    "eccentricity": 0.0549006,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let mars = {
                "type": "planet",
                "diameter": 6779,
                "AU": 1.5 * 200 + 40,
                "obliquity": 25.19,
                "orbital_period": 1.881 * 365.25636,
                "rotate_period": 1.02595675,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 1.524 * 200 + 40,
                    "semi_minor": 1.5174 * 200 + 40,
                    "eccentricity": 0.09296592,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let jupiter = {
                "type": "planet",
                "diameter": 139820,
                "AU": 5.2 * 200 + 40,
                "obliquity": 3.13,
                "orbital_period": 11.86 * 365.25636,
                "rotate_period": 0.41007,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 5.2044 * 200 + 40,
                    "semi_minor": 5.1982 * 200 + 40,
                    "eccentricity": 0.048797337,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let saturn = {
                "type": "planet",
                "diameter": 116460,
                "AU": 9.5 * 200 + 40,
                "obliquity": 26.73,
                "orbital_period": 29.46 * 365.25636,
                "rotate_period": 0.426,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 9.5826 * 200 + 40,
                    "semi_minor": 9.5673 * 200 + 40,
                    "eccentricity": 0.056486623,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
                "ring": {
                    "diameter_inner": 183460 + 133590,
                    "diameter_outter": 116460 + 116460*0.5,
                },
            };
            let uranus = {
                "type": "planet",
                "diameter": 50724,
                "AU": 19.2 * 200 + 40,
                "obliquity": 97.77,
                "orbital_period": 84.01 * 365.25636,
                "rotate_period": 0.71833,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 19.21840 * 200 + 40,
                    "semi_minor": 19.19770 * 200 + 40,
                    "eccentricity": 0.046400705,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let neptune = {
                "type": "planet",
                "diameter": 49244,
                "AU": 30.1 * 200 + 40,
                "obliquity": 28.32,
                "orbital_period": 164.8 * 365.25636,
                "rotate_period": 0.67125,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 30.11000 * 200 + 40,
                    "semi_minor": 30.10870 * 200 + 40,
                    "eccentricity": 0.009292372,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            let pluto = {
                "type": "dwarf planet",
                "diameter": 2377,
                "AU": 39.5 * 200 + 40,
                "obliquity": 122.53,
                "orbital_period": 248.1 * 365.25636,
                "rotate_period": 6.38718,
                "orbital_angle": 0,
                "rotate_angle": 0,
                "count": {
                    "orbit": 0,
                    "rotate": 0,
                },
                "cloud": {
                    "type": "cloud",
                },
                "orbit": {
                    "semi_major": 39.48168677 * 200 + 40,
                    "semi_minor": 38.24010279 * 200 + 40,
                    "eccentricity": 0.24880766,
                    "semi_latus": 0,
                    "perihelion": 0,
                    "aphelion": 0,
                    "radius": 0,
                },
            };
            
            earth.speed = 1;

            let virtual_time = {};
            virtual_time.years = 0;
            virtual_time.months = 0;
            virtual_time.days = 0;

            // 攝影機參數
            let camera = {};
            camera.position = vec3.set(vec3.create(), 242, 0, 29);
            camera.direction = vec3.set(vec3.create(), 0, 0, -1);
            camera.traget = vec3.create();
            camera.worldUp = vec3.set(vec3.create(), 0, 1, 0);
            camera.up = vec3.copy(vec3.create(), camera.worldUp);
            camera.right = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), camera.direction, camera.worldUp));
            camera.movespeed = 0.5;
            camera.sensitivity = 0.05;
            camera.pitch = 0;
            camera.yaw = 0;

            let color = vec3.set(vec3.create(), 1, 0.2, 0.3);
            let isShowTexture = true;
            let currentTexture = 0;

            let shaderProgram;

            let matrix_modes= ['view', 'model', 'projection', 'texture', 'color'];
            let Matries = [];

            let currentPressedKeys = {};

            let currentFrame = new Date().getTime();
            let lastFrame = 0;
            let deltaFrame = 0;

            let axisOff = false;
            let orbitOff = false;
            let isInfoPlaneOn = true;
            let isRenderingSun = false;
            let isRenderingSpace = false;
            let isCubeMap = false;
            
            let currentLighting = 2;
            let lightingModels = [
                {
                    id: 0,
                    name: 'No Lighting'
                },
                {
                    id: 1,
                    name: 'Phong Lighting'
                },
                {
                    id: 2,
                    name: 'Blinn-Phong Lighting'
                }
            ];

            function initGL(canvas) {
                try {
                    gl = canvas.getContext('experimental-webgl');
                    gl.viewportWidth = canvas.width;
                    gl.viewportHeight = canvas.height;
                } catch (e) {

                }

                if (!gl) {
                    alert("Cloud not initialize WebGL.");
                    console.error('Cloud not initialize WebGL.');
                }
            }

            // create a shader
            function createShader(gl, shaderID) {
                let shader;
                let shaderType = $(shaderID).attr('type');;
                
                if(shaderType == 'x-shader/x-vertex'){
                    shader = gl.createShader(gl.VERTEX_SHADER);
                }else if(shaderType == 'x-shader/x-fragment') {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                }else {
                    console.error('ERROR：The shader type is unknow.');
                    return NULL;
                }

                let source = $(shaderID).html();
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
                    console.error('ERROR：Failed to compile shader, type:' + shaderType + ', reason: ' + gl.getShaderInfoLog(shader));
                    return NULL;
                }

                return shader;
            }

            // create and link shader program
            function createProgram(vertexShaderID, fragmentShaderID) {
                let vertexShader = createShader(gl, '#' + vertexShaderID);
                let fragmentShader = createShader(gl, '#' + fragmentShaderID);

                let shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)){
                    console.error('ERROR：Failed to link the program' + ', reason: ' + gl.getProgramInfoLog(shaderProgram));
                }

                return shaderProgram;
            }

            // inital shaders
            function initShaders() {
                shaderProgram = createProgram('vertex', 'fragment');

                gl.useProgram(shaderProgram);
                shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
                shaderProgram.normalAttribute = gl.getAttribLocation(shaderProgram, 'aNormal');
                shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, 'aTextureCoord');
                shaderProgram.model = gl.getUniformLocation(shaderProgram, 'model');
                shaderProgram.view = gl.getUniformLocation(shaderProgram, 'view');
                shaderProgram.projection = gl.getUniformLocation(shaderProgram, 'projection');
                shaderProgram.normalModel = gl.getUniformLocation(shaderProgram, 'normalModel');
                shaderProgram.color = gl.getUniformLocation(shaderProgram, 'color');
                shaderProgram.enableTexture = gl.getUniformLocation(shaderProgram, 'enableTexture');
                shaderProgram.lightPosition = gl.getUniformLocation(shaderProgram, 'lightPosition');
                shaderProgram.viewPos = gl.getUniformLocation(shaderProgram, 'viewPos');
                shaderProgram.isRenderingSun = gl.getUniformLocation(shaderProgram, 'isRenderingSun');
                shaderProgram.isRenderingSpace = gl.getUniformLocation(shaderProgram, 'isRenderingSpace');
                // shaderProgram.time = gl.getUniformLocation(shaderProgram, 'time');
                shaderProgram.currentLighting = gl.getUniformLocation(shaderProgram, 'currentLighting');

                shaderProgram.material = {};
                shaderProgram.material.diffuse = gl.getUniformLocation(shaderProgram, 'material.diffuse');
                shaderProgram.material.specular = gl.getUniformLocation(shaderProgram, 'material.specular');
                shaderProgram.material.shininess = gl.getUniformLocation(shaderProgram, 'material.shininess');

                shaderProgram.light = {};
                shaderProgram.light.position = gl.getUniformLocation(shaderProgram, 'light.position');
                shaderProgram.light.ambient = gl.getUniformLocation(shaderProgram, 'light.ambient');
                shaderProgram.light.diffuse = gl.getUniformLocation(shaderProgram, 'light.diffuse');
                shaderProgram.light.specular = gl.getUniformLocation(shaderProgram, 'light.specular');
                shaderProgram.light.constant = gl.getUniformLocation(shaderProgram, 'light.constant');
                shaderProgram.light.linear = gl.getUniformLocation(shaderProgram, 'light.linear');
                shaderProgram.light.quadratic = gl.getUniformLocation(shaderProgram, 'light.quadratic');


                shaderProgram.isCubeMap = gl.getUniformLocation(shaderProgram, 'isCubeMap');
                shaderProgram.skybox = gl.getUniformLocation(shaderProgram, 'skybox');
            }

            // Loading textures
            function loadTexture(filepath){
                let texture = gl.createTexture();
                texture.image = new Image();
                
                texture.image.onload = function() {
                    handleLoadedTexture(texture);
                }

                texture.image.src = filepath;
                return texture;
            }

            function handleLoadedTexture(texture) {
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
                // gl.generateMipmap(gl.TEXTURE_2D);

                if(isPowerOfTwo(texture.image.width) && isPowerOfTwo(texture.image.height)){
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                } else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            function isPowerOfTwo(x){
                return (x & (x - 1)) == 0;
            }

            // Loading cubemap texture (don't have a filename include in filepath)
            function loadCubeMap(filepath, ext){
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                const faceInfos = [
                    {
                        target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, 
                        url: filepath + '/' + 'right' + '.' + ext,
                    },
                    {
                        target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 
                        url: filepath + '/' + 'left' + '.' + ext,
                    },
                    {
                        target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 
                        url: filepath + '/' + 'top' + '.' + ext,
                    },
                    {
                        target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 
                        url: filepath + '/' + 'bottom' + '.' + ext,
                    },
                    {
                        target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 
                        url: filepath + '/' + 'front' + '.' + ext,
                    },
                    {
                        target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 
                        url: filepath + '/' + 'back' + '.' + ext,
                    },
                ];

                faceInfos.forEach((faceInfo) => {
                    const {target, url} = faceInfo;
                    
                    // Upload the canvas to the cubemap face.
                    const level = 0;
                    const internalFormat = gl.RGBA;
                    const width = 2048;
                    const height = 2048;
                    const format = gl.RGBA;
                    const type = gl.UNSIGNED_BYTE;
                    
                    // setup each face so it's immediately renderable
                    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
                    
                    // Asynchronously load an image
                    const image = new Image();
                    image.src = url;
                    image.addEventListener('load', function() {
                        // Now that the image has loaded upload it to the texture.
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                        gl.texImage2D(target, level, internalFormat, format, type, image);
                        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                    });
                });
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
                
                return texture;
            }

            function initMatrix() {
                for(let i = 0; i < matrix_modes.length; i++) {
                    Matries[matrix_modes[i]] = [mat4.create()];
                }
            }

            function topMatrix(matrix_mode) {
                return Matries[matrix_mode][Matries[matrix_mode].length - 1];
            }

            function pushMatrix(matrix_mode) {
                let copy = mat4.create();
                mat4.copy(copy, topMatrix(matrix_mode));
                Matries[matrix_mode].push(copy);
            }

            function popMatrix(matrix_mode) {
                if(Matries[matrix_mode].length == 0) {
                    throw "Invalid popMatrix";
                }
                Matries[matrix_mode].pop();
            }

            function setMatrixUniforms(type = 'shaderProgram') {
                if (type == 'shaderProgram') {
                    gl.useProgram(shaderProgram);
                    gl.uniformMatrix4fv(shaderProgram.model, false, topMatrix('model'));
                    gl.uniformMatrix4fv(shaderProgram.view, false, topMatrix('view'));
                    gl.uniformMatrix4fv(shaderProgram.projection, false, topMatrix('projection'));
                    gl.uniformMatrix3fv(shaderProgram.normalModel, false, mat3.normalFromMat4(mat3.create(), topMatrix('model')));
                    gl.uniform3fv(shaderProgram.color, color);
                    gl.uniform1i(shaderProgram.enableTexture, isShowTexture);
                    gl.uniform3fv(shaderProgram.viewPos, camera.position);
                    gl.uniform1i(shaderProgram.isRenderingSun, isRenderingSun);
                    gl.uniform1i(shaderProgram.isRenderingSpace, isRenderingSpace);
                    gl.uniform1i(shaderProgram.currentLighting, currentLighting);

                    gl.uniform1i(shaderProgram.material.diffuse, 0);
                    gl.uniform1i(shaderProgram.material.specular, 1);
                    gl.uniform1f(shaderProgram.material.shininess, 64.0);

                    gl.uniform3fv(shaderProgram.light.position, sun.position);
                    gl.uniform3fv(shaderProgram.light.ambient, vec3.set(vec3.create(), 0.02, 0.02, 0.02));
                    // gl.uniform3fv(shaderProgram.light.ambient, vec3.set(vec3.create(), 0.8, 0.8, 0.8));
                    gl.uniform3fv(shaderProgram.light.diffuse, vec3.set(vec3.create(), 0.8, 0.8, 0.8));
                    gl.uniform3fv(shaderProgram.light.specular, vec3.set(vec3.create(), 0.2, 0.3, 0.2));

                    gl.uniform1f(shaderProgram.light.constant, 1.0);
                    gl.uniform1f(shaderProgram.light.linear, 0.00000000014);
                    gl.uniform1f(shaderProgram.light.quadratic, 0.000000009);     

                    gl.uniform1i(shaderProgram.isCubeMap, isCubeMap);
                    gl.uniform1i(shaderProgram.skybox, 2);
                } else {
                    console.error('ERROR：The shader program type is unknow.');
                }
            }

            function deg2Rad(degrees) {
                return degrees * Math.PI / 180;
            }

            function getRandomArbitrary(min, max) {
                return Math.random() * (max - min) + min;
            }

            function initBuffers() {
                cube.vertices = [
                    // Vertex           // Texture Coord

                    // Front            
                    -1.0,  1.0,  1.0,   0.0, 0.0, 1.0,      1.0, 0.0,
                     1.0,  1.0,  1.0,   0.0, 0.0, 1.0,      1.0, 1.0, 
                     1.0, -1.0,  1.0,   0.0, 0.0, 1.0,      0.0, 1.0,
                    -1.0, -1.0,  1.0,   0.0, 0.0, 1.0,      0.0, 0.0,

                    // Back
                    -1.0,  1.0, -1.0,   0.0, 0.0, -1.0,     1.0, 0.0,
                     1.0,  1.0, -1.0,   0.0, 0.0, -1.0,     1.0, 1.0,
                     1.0, -1.0, -1.0,   0.0, 0.0, -1.0,     0.0, 1.0,
                    -1.0, -1.0, -1.0,   0.0, 0.0, -1.0,     0.0, 0.0,

                    // Bottom
                    -1.0, -1.0, -1.0,   0.0, -1.0, 0.0,     1.0, 0.0,
                     1.0, -1.0, -1.0,   0.0, -1.0, 0.0,     1.0, 1.0,
                     1.0, -1.0,  1.0,   0.0, -1.0, 0.0,     0.0, 1.0,
                    -1.0, -1.0,  1.0,   0.0, -1.0, 0.0,     0.0, 0.0,

                    // Top
                    -1.0,  1.0, -1.0,   0.0, 1.0, 0.0,      1.0, 0.0,
                     1.0,  1.0, -1.0,   0.0, 1.0, 0.0,      1.0, 1.0,
                     1.0,  1.0,  1.0,   0.0, 1.0, 0.0,      0.0, 1.0,
                    -1.0,  1.0,  1.0,   0.0, 1.0, 0.0,      0.0, 0.0,

                    // Left
                    -1.0,  1.0,  1.0,  -1.0, 0.0, 0.0,     1.0, 0.0,
                    -1.0,  1.0, -1.0,  -1.0, 0.0, 0.0,     1.0, 1.0,
                    -1.0, -1.0, -1.0,  -1.0, 0.0, 0.0,     0.0, 1.0,
                    -1.0, -1.0,  1.0,  -1.0, 0.0, 0.0,     0.0, 0.0,

                    // Right
                     1.0,  1.0,  1.0,   1.0, 0.0, 0.0,     1.0, 0.0,
                     1.0,  1.0, -1.0,   1.0, 0.0, 0.0,     1.0, 1.0,
                     1.0, -1.0, -1.0,   1.0, 0.0, 0.0,     0.0, 1.0,
                     1.0, -1.0,  1.0,   1.0, 0.0, 0.0,     0.0, 0.0,
                ];
                cube.indices = [
                    0, 1, 2,        0, 2, 3,
                    4, 5, 6,        4, 6, 7,
                    8, 9, 10,       8, 10, 11,
                    12, 13, 14,     12, 14, 15,
                    16, 17, 18,     16, 18, 19,
                    20, 21, 22,     20, 22, 23,
                ];
                cube.vbo = gl.createBuffer();
                cube.ebo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cube.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube.vertices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.ebo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube.indices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
                gl.enableVertexAttribArray(shaderProgram.normalAttribute);
                gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

                // genSphereBuffer(sphere, 1, 30, 30);
                genSphereBuffer(space, space.diameter, 30, 30);
                genSphereBuffer(sun, sun.diameter * 4 / jupiter.diameter, 30, 30);
                genSphereBuffer(mercury, mercury.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(venus, venus.diameter * 0.99 * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(venus.cloud, venus.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(earth, earth.diameter * 0.99 * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(earth.cloud, earth.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(moon, moon.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(mars, mars.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(jupiter, 40, 30, 30);
                genSphereBuffer(saturn, saturn.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(uranus, uranus.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(neptune, neptune.diameter * (40 / jupiter.diameter), 30, 30);
                genSphereBuffer(pluto, pluto.diameter * (40 / jupiter.diameter), 30, 30);

                genEllipseBuffer(mercury.orbit);
                genEllipseBuffer(venus.orbit);
                genEllipseBuffer(earth.orbit);
                genEllipseBuffer(moon.orbit);
                genEllipseBuffer(mars.orbit);
                genEllipseBuffer(jupiter.orbit);
                genEllipseBuffer(saturn.orbit);
                genEllipseBuffer(uranus.orbit);
                genEllipseBuffer(neptune.orbit);
                genEllipseBuffer(pluto.orbit);

                genRingBuffer(saturn.ring, saturn.ring.diameter_inner * (40 / jupiter.diameter), saturn.ring.diameter_outter * (40 / jupiter.diameter));

                initMatrix();
            }

            function getRandomArbitrary(min, max) {
                return Math.random() * (max - min) + min;
            }

            function genRingBuffer(obj, radius_inner = 1, radius_outer = 0.5, stack = 180){
                obj.radius_inner = radius_inner;
                obj.radius_outer = radius_outer;
                obj.vertices = [];
                obj.indices = [];

                for(let i = 0; i <= stack * 4; i++){
                    let theta = i * Math.PI / stack;
                    let sinTheta = Math.sin(theta);
                    let cosTheta = Math.cos(theta);

                    let x = sinTheta;
                    let y = 0;
                    let z = cosTheta;
                    

                    obj.vertices.push(obj.radius_inner * x);
                    obj.vertices.push(0);
                    obj.vertices.push(obj.radius_inner * z);

                    // Generate normal vector (fake)
                    let temp = vec3.set(vec3.create(), 2 * obj.radius_inner * x , 2 * obj.radius_inner * y, 2 * obj.radius_inner * z);
                    let normal = vec3.normalize(vec3.create(), temp);
                    obj.vertices.push(0);
                    obj.vertices.push(1);
                    obj.vertices.push(0);

                    // Generate texture coordinate (fake)
                    let u = 0;
                    let v = 0;
                    obj.vertices.push(u);
                    obj.vertices.push(v);

                    obj.vertices.push(obj.radius_outer * x);
                    obj.vertices.push(0);
                    obj.vertices.push(obj.radius_outer * z);

                    // Generate normal vector (fake)
                    temp = vec3.set(vec3.create(), 2 * obj.radius_outer * x , 2 * obj.radius_outer * y, 2 * obj.radius_outer * z);
                    normal = vec3.normalize(vec3.create(), temp);
                    obj.vertices.push(0);
                    obj.vertices.push(1);
                    obj.vertices.push(0);

                    // Generate texture coordinate (fake)
                    u = 1;
                    v = 1 - (i / stack)
                    obj.vertices.push(u);
                    obj.vertices.push(v);
                }

                // 除以8 * 2 = 16 是因為兩個圓 和 8個object
                let totalStack = obj.vertices.length / 16;
                for (let i = 0; i < totalStack; i++) {
                    let first = totalStack + 1 + i;
                    let second = first + totalStack + 1;
                    first = i;
                    second = first + totalStack + 1;
                    obj.indices.push(first);
                    obj.indices.push(second);
                    obj.indices.push(first + 1);

                    obj.indices.push(second);
                    obj.indices.push(second + 1);
                    obj.indices.push(first + 1);
                }
                
                // Bind buffer
                obj.vbo = gl.createBuffer();
                obj.ebo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ebo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(obj.indices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
                gl.enableVertexAttribArray(shaderProgram.normalAttribute);
                gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

            function genEllipseBuffer(obj, stack = 180){

                // obj.eccentricity = Math.sqrt(1 - (Math.pow((obj.semi_minor - 20) / 200, 2) / Math.pow((obj.semi_major - 20) / 200, 2)));
                obj.semi_latus = Math.pow(obj.semi_minor, 2) / obj.semi_major;
                obj.perihelion = obj.semi_latus / (1 + obj.eccentricity * Math.cos(0));
                obj.aphelion = obj.semi_latus / (1 + obj.eccentricity * Math.cos(180));

                obj.vertices = [];
                obj.indices = [];

                for(let i = 0; i <= stack * 2; i++){
                    let theta = i * Math.PI / stack;
                    let sinTheta = Math.sin(theta);
                    let cosTheta = Math.cos(theta);

                    let x = sinTheta;
                    let z = cosTheta;

                    obj.vertices.push(obj.semi_major * x);
                    obj.vertices.push(0);
                    obj.vertices.push(obj.semi_minor * z);

                    // Generate normal vector (fake)
                    obj.vertices.push(0);
                    obj.vertices.push(0);
                    obj.vertices.push(0);

                    // Generate texture coordinate (fake)
                    let u = 1;
                    let v = 1 - (i / stack);
                    obj.vertices.push(u);
                    obj.vertices.push(v * -1);

                    obj.indices.push(i);
                    if(i == stack * 2){
                        obj.indices.push(0);
                    }else{
                        obj.indices.push(i + 1);
                    }
                }

                // Bind buffer
                obj.vbo = gl.createBuffer();
                obj.ebo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ebo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(obj.indices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
                gl.enableVertexAttribArray(shaderProgram.normalAttribute);
                gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

            function genSphereBuffer(obj, radius, lati, long){
                obj.radius = radius;
                obj.latitude = lati;
                obj.longitude = long;

                // Generate Sphere Vertices
                obj.vertices = [];
                for(let i = 0; i <= obj.latitude; i++){
                    let theta = i * Math.PI / obj.latitude;
                    let sinTheta = Math.sin(theta);
                    let cosTheta = Math.cos(theta);
                    for(let j = 0; j <= obj.longitude; j++){
                        let phi = j * 2 * Math.PI / obj.longitude;
                        let sinPhi = Math.sin(phi);
                        let cosPhi = Math.cos(phi);

                        let x = cosPhi * sinTheta;
                        let y = cosTheta;
                        let z = sinPhi * sinTheta;

                        obj.vertices.push(obj.radius * x);
                        obj.vertices.push(obj.radius * y);
                        obj.vertices.push(obj.radius * z);

                        // Generate normal vector
                        let temp = vec3.set(vec3.create(), 2 * obj.radius * x , 2 * obj.radius * y, 2 * obj.radius * z);
                        let normal = vec3.normalize(vec3.create(), temp);
                        obj.vertices.push(normal[0]);
                        obj.vertices.push(normal[1]);
                        obj.vertices.push(normal[2]);

                        // Generate texture coordinate
                        let u = 1 - (j / obj.longitude);
                        let v = 1 - (i / obj.latitude);
                        obj.vertices.push(u);
                        obj.vertices.push(v);
                    }
                }

                // Generate Sphere Indices
                obj.indices = [];
                for(let i = 0; i < obj.latitude; i++){
                    for(let j = 0; j < obj.longitude; j++){
                        let first = (i * (obj.longitude + 1)) + j;
                        let second = first + obj.longitude + 1;
                        obj.indices.push(first);
                        obj.indices.push(second);
                        obj.indices.push(first + 1);

                        obj.indices.push(second);
                        obj.indices.push(second + 1);
                        obj.indices.push(first + 1);
                    }
                }

                // Bind buffer
                obj.vbo = gl.createBuffer();
                obj.ebo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.vbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ebo);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(obj.indices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
                gl.enableVertexAttribArray(shaderProgram.normalAttribute);
                gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            }

            function handleKeyDown(event) {
                //console.log(event.keyCode);
                currentPressedKeys[event.keyCode] = true;

                // F
                if(currentPressedKeys[70]){
                    if(axisOff){
                        axisOff = false;
                    }else{
                        axisOff = true;
                    }
                }

                // G
                if(currentPressedKeys[71]){
                    if(orbitOff){
                        orbitOff = false;
                    }else{
                        orbitOff = true;
                    }
                }

                // L
                if(currentPressedKeys[76]){
                    if(currentLighting == 2){
                        currentLighting = 0;
                    }else{
                        currentLighting += 1;
                    }
                }
            }

            function handleKeyUp(event) {
                currentPressedKeys[event.keyCode] = false;
            }

            function handleKeys() {
                let velocity = camera.movespeed * deltaFrame;
                if(currentPressedKeys[87]){
                    // w
                    vec3.add(camera.position, camera.position, vec3.scale(vec3.create(), camera.direction, velocity));
                }
                if(currentPressedKeys[83]){
                    // s
                    vec3.sub(camera.position, camera.position, vec3.scale(vec3.create(), camera.direction, velocity));
                }
                if(currentPressedKeys[65]){
                    // a
                    vec3.sub(camera.position, camera.position, vec3.scale(vec3.create(), camera.right, velocity));
                }
                if(currentPressedKeys[68]){
                    // d
                    vec3.add(camera.position, camera.position, vec3.scale(vec3.create(), camera.right, velocity));
                }

                if(currentPressedKeys[86]){
                    // v
                    if(earth.speed < 20000){
                        earth.speed += 10 * deltaFrame;
                        if(earth.speed > 20000){
                            earth.speed = 20000;
                        }
                    }else{
                        earth.speed = 20000;
                        console.error("轉速只能介於0到20000之間。");
                    }
                }
                if(currentPressedKeys[67]){
                    // c
                    if(earth.speed > 0){
                        earth.speed -= 10 * deltaFrame;
                        if(earth.speed < 0){
                            earth.speed = 0;
                        }
                    }else{
                        earth.speed = 0;
                        console.error("轉速只能介於0到20000之間。");
                    }
                }

                // Right Shift
                if(currentPressedKeys[16]){
                    camera.movespeed = 2.0;
                }else{
                    camera.movespeed = 0.2;
                }
                updateCameraStatus();
            }

            function handleMouseMove(event) {
                let offsetX = event.movementX * -1;
                let offsetY = event.movementY * -1;

                offsetX *= camera.sensitivity;
                offsetY *= camera.sensitivity;

                camera.yaw += offsetX;
                camera.pitch += offsetY;

                if(camera.pitch > 89.0) {
                    camera.pitch = 89.0;
                }
                if(camera.pitch < -89.0) {
                    camera.pitch = -89.0;
                }

                if(camera.yaw > 360) {
                    camera.yaw -= 360;
                }
                if(camera.yaw < -360.0) {
                    camera.yaw += 360.0;
                }

                updateCameraParameter();
            }

            function updateCameraParameter(){
                let rotatematrix = mat4.create();
                
                mat4.rotate(rotatematrix, rotatematrix, deg2Rad(camera.yaw), [0, 1, 0]);
                mat4.rotate(rotatematrix, rotatematrix, deg2Rad(camera.pitch), [1, 0, 0]);
                
                let direction = vec4.set(vec4.create(), 0, 0, -1, 1);
                vec4.transformMat4(direction, direction, rotatematrix);
                
                camera.direction = vec3.normalize(vec3.create(), vec3.set(vec3.create(), direction[0], direction[1], direction[2]));
                camera.right = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), camera.direction, camera.worldUp));
                camera.up = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), camera.right, camera.direction));

                updateCameraStatus();
            }

            function handleMouseDown(event){

            }

            function tick() {
                requestAnimationFrame(tick);
                handleKeys();
                drawScene();
                animate();
            }

            function animate() {
                currentFrame = new Date().getTime();
                if(lastFrame != 0) {
                    deltaFrame = currentFrame - lastFrame;

                    earth.rotate_angle += (earth.speed * deltaFrame) / 1000.0;
                    limitTo360Deg(earth, "rotate_angle");

                    earth.orbital_angle += (earth.speed / earth.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(earth, "orbital_angle");

                    // let temp = vec3.negate(vec3.create(), vec3.normalize(vec3.create(), earth.position)) ;
                    // earth.acceleration = vec3.scale(vec3.create(), temp, G * sun.mass / vec3.len(earth.position)^2)
                    // earth.velocity = vec3.add(vec3.create(), earth.velocity, earth.acceleration);
                    // earth.position = vec3.add(vec3.create(), earth.position, vec3.scale(vec3.create(), earth.velocity, deltaFrame / 1000.0));

                    moon.orbital_angle += earth.speed / moon.orbital_period * deltaFrame / 1000.0;
                    limitTo360Deg(moon, "orbital_angle");
                    moon.orbit.radius = moon.orbit.semi_latus / (1 + moon.orbit.eccentricity * Math.cos(deg2Rad(moon.orbital_angle)));

                    sun.rotate_angle += (earth.speed / sun.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(sun, "rotate_angle");

                    mercury.rotate_angle += (earth.speed / mercury.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(mercury, "rotate_angle");
                    mercury.orbital_angle += (earth.speed / mercury.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(mercury, "orbital_angle");
                    mercury.orbit.radius = mercury.orbit.semi_latus / (1 + mercury.orbit.eccentricity * Math.cos(deg2Rad(mercury.orbital_angle)));

                    venus.rotate_angle += (earth.speed / venus.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(venus, "rotate_angle");
                    venus.orbital_angle += (earth.speed / venus.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(venus, "orbital_angle");

                    mars.rotate_angle += (earth.speed / mars.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(mars, "rotate_angle");
                    mars.orbital_angle += (earth.speed / mars.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(mars, "orbital_angle");

                    jupiter.rotate_angle += (earth.speed / jupiter.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(jupiter, "rotate_angle");
                    jupiter.orbital_angle += (earth.speed / jupiter.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(jupiter, "orbital_angle");

                    saturn.rotate_angle += (earth.speed / saturn.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(saturn, "rotate_angle");
                    saturn.orbital_angle += (earth.speed / saturn.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(saturn, "orbital_angle");

                    uranus.rotate_angle += (earth.speed / uranus.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(uranus, "rotate_angle");
                    uranus.orbital_angle += (earth.speed / uranus.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(uranus, "orbital_angle");

                    neptune.rotate_angle += (earth.speed / neptune.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(neptune, "rotate_angle");
                    neptune.orbital_angle += (earth.speed / neptune.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(neptune, "orbital_angle");

                    pluto.rotate_angle += (earth.speed / pluto.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(pluto, "rotate_angle");
                    pluto.orbital_angle += (earth.speed / pluto.orbital_period * deltaFrame) / 1000.0;
                    limitTo360Deg(pluto, "orbital_angle");

                    space.obliquity += 0.5 * deltaFrame / 1000.0;
                    space.rotate_angle += (earth.speed / space.rotate_period * deltaFrame) / 1000.0;
                    limitTo360Deg(space, "rotate_angle");
                }
                lastFrame = currentFrame;
            }

            function limitTo360Deg(object, type){
                if(type == 'rotate_angle'){
                    if(object.rotate_angle > 360){
                        object.rotate_angle = object.rotate_angle - 360;
                        object.count.rotate += 1;
                    }
                }else if(type == 'orbital_angle'){
                    if(object.orbital_angle > 360){
                        object.orbital_angle = object.orbital_angle - 360;
                        object.count.orbit += 1;
                    }
                }else{
                    error.log("Unknow type error!");
                }
            }

            function darwRing(object){
                isShowTexture = true;
                color = vec3.set(vec3.create(), 0.8, 0.8, 0.6);
                pushMatrix('model');
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, object.texture);
                    gl.activeTexture(gl.TEXTURE1);
                    gl.bindTexture(gl.TEXTURE_2D, object.texture);
                    gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ebo);
                    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 0);
                    gl.vertexAttribPointer(shaderProgram.normalAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
                    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
                    setMatrixUniforms('shaderProgram');
                    gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT, 0);
                popMatrix('model');
                isShowTexture = true;
            }

            function darwOrbit(object){
                if(orbitOff){
                    isShowTexture = false;
                    color = vec3.set(vec3.create(), 0.8, 0.8, 0.6);
                    pushMatrix('model');
                        gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ebo);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 0);
                        gl.vertexAttribPointer(shaderProgram.normalAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
                        setMatrixUniforms('shaderProgram');
                        gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, 0);
                    popMatrix('model');
                    isShowTexture = true;
                }
            }
            
            function drawSphere(object, neverShowAxis = false, specular = false){
                pushMatrix('model');

                    // 如果是繪製太陽將會特別備註 (因為太陽會自發光)
                    if(object.type == "star"){
                        isRenderingSun = true;
                    }else{
                        isRenderingSun = false;
                    }

                    // 如果是繪製宇宙(背景)特別備註 (使用cubemap)
                    if(object.type == "universe"){
                        isRenderingSpace = true;
                    }else{
                        isRenderingSpace = false;
                    }

                    // 載入貼圖
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, object.texture);

                    // 此球體是否包含 specular texture，統一綁定在 texture1。
                    if(specular){
                        gl.activeTexture(gl.TEXTURE1);
                        gl.bindTexture(gl.TEXTURE_2D, object.specular_texture);
                    }else{
                        gl.activeTexture(gl.TEXTURE1);
                        gl.bindTexture(gl.TEXTURE_2D, object.texture);
                    }

                    // 開始繪製球體
                    gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ebo);
                    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 0);
                    gl.vertexAttribPointer(shaderProgram.normalAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
                    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
                    setMatrixUniforms('shaderProgram');
                    gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT, 0);
                    if(!axisOff && !neverShowAxis){
                        drawAxis(object.radius);
                    }
                popMatrix('model');
            }

            function drawCube(){
                pushMatrix('model');
                    gl.bindBuffer(gl.ARRAY_BUFFER, cube.vbo);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.ebo);
                    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 0);
                    gl.vertexAttribPointer(shaderProgram.normalAttribute, 3, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
                    gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, 2, gl.FLOAT, false, 8 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
                    setMatrixUniforms('shaderProgram');
                    gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);
                popMatrix('model');
            }

            function drawAxis(radius){
                isShowTexture = false;
                let cubesize = radius * 0.025;
                let offset = radius * 0.25;
                pushMatrix('model');
                    color = vec3.set(vec3.create(), 1.0, 0.0, 0.0);
                    mat4.translate(topMatrix('model'), topMatrix('model'), [radius / 2 + offset, 0, 0]);
                    mat4.scale(topMatrix('model'), topMatrix('model'), [radius / 2 + offset, cubesize, cubesize]);
                    drawCube();
                popMatrix('model');
                pushMatrix('model');
                    color = vec3.set(vec3.create(), 0.0, 1.0, 0.0);
                    mat4.translate(topMatrix('model'), topMatrix('model'), [0, radius / 2 + offset, 0]);
                    mat4.scale(topMatrix('model'), topMatrix('model'), [cubesize, radius / 2 + offset, cubesize]);
                    drawCube();
                popMatrix('model');
                pushMatrix('model');
                    color = vec3.set(vec3.create(), 0.0, 0.0, 1.0);
                    mat4.translate(topMatrix('model'), topMatrix('model'), [0, 0, radius / 2 + offset]);
                    mat4.scale(topMatrix('model'), topMatrix('model'), [cubesize, cubesize, radius / 2 + offset]);
                    drawCube();
                popMatrix('model');
                isShowTexture = true;
            }

            function drawScene() {
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                mat4.identity(topMatrix('projection'));
                mat4.perspective(topMatrix('projection'), 45, gl.viewportWidth / gl.viewportHeight, 0.1, 20000.0);
                
                mat4.identity(topMatrix('view'));
                let lookAtMatrix = mat4.create(topMatrix('view'));
                vec3.add(camera.traget, camera.position, camera.direction);
                mat4.lookAt(lookAtMatrix, camera.position, camera.traget, camera.worldUp);
                mat4.multiply(topMatrix('view'), topMatrix('view'), lookAtMatrix);
                
                mat4.identity(topMatrix('model'));

                // 繪製天空盒（使用Cubemap）
                isCubeMap = true;
                isRenderingSpace = true;
                gl.depthFunc(gl.LEQUAL);
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, cube.texture);
                pushMatrix('model');
                    mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(space.obliquity), [1, 0, 0]);
                    mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(space.rotate_angle), [0, 1, 0]);
                    drawCube();
                popMatrix('model');
                gl.depthFunc(gl.LESS);
                isRenderingSpace = false;
                isCubeMap = false;

                // 繪製太空
                // pushMatrix('model');
                //     mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(space.obliquity), [1, 0, 0]);
                //     mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(space.rotate_angle), [0, 1, 0]);
                //     drawSphere(space, true);
                // popMatrix('model');

                // 繪製太陽
                pushMatrix('model');
                    mat4.translate(topMatrix('model'), topMatrix('model'), sun.position);
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(sun.obliquity), [-1, 0, 0]);
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(sun.rotate_angle), [0, 1, 0]);
                        drawSphere(sun);
                    popMatrix('model');

                    // 水星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [-mercury.orbit.semi_major + mercury.orbit.perihelion, 0, 0]);
                        darwOrbit(mercury.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mercury.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [mercury.orbit.radius, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mercury.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mercury.rotate_angle), [0, 1, 0]);
                            drawSphere(mercury);
                        popMatrix('model');
                    popMatrix('model');

                    // 金星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [venus.orbit.semi_major - venus.orbit.perihelion, 0, 0]);
                        darwOrbit(venus.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(venus.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [venus.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(venus.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(venus.rotate_angle), [0, 1, 0]);
                            drawSphere(venus);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(venus.rotate_angle), [0, 1, 0]);
                            drawSphere(venus.cloud, true);
                        popMatrix('model');
                    popMatrix('model');

                    // 地球
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [earth.orbit.semi_major - earth.orbit.perihelion, 0, 0]);
                        darwOrbit(earth.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(earth.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [earth.AU, 0, 0]);
                        // mat4.translate(topMatrix('model'), topMatrix('model'), earth.position);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(earth.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(earth.rotate_angle), [0, 1, 0]);
                            drawSphere(earth, false, true);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(earth.rotate_angle), [0, 1, 0]);
                            drawSphere(earth.cloud, true);
                        popMatrix('model');

                        // 月亮
                        pushMatrix('model');
                            mat4.translate(topMatrix('model'), topMatrix('model'), [moon.orbit.semi_major - moon.orbit.perihelion, 0, 0]);
                            darwOrbit(moon.orbit);
                        popMatrix('model');
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(moon.orbital_angle), [0, 1, 0]);
                            mat4.translate(topMatrix('model'), topMatrix('model'), [moon.AU, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(moon.obliquity), [-1, 0, 0]);
                            // 不用加上月球自轉，因為前者的旋轉就是針對月球的 local coordinate 
                            // mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(0), [0, 1, 0]);
                            drawSphere(moon);
                        popMatrix('model');
                    popMatrix('model');

                    // 火星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [mars.orbit.semi_major - mars.orbit.perihelion, 0, 0]);
                        darwOrbit(mars.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mars.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [mars.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mars.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(mars.rotate_angle), [0, 1, 0]);
                            drawSphere(mars);
                        popMatrix('model');
                    popMatrix('model');

                    // 木星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [jupiter.orbit.semi_major - jupiter.orbit.perihelion, 0, 0]);
                        darwOrbit(jupiter.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(jupiter.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [jupiter.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(jupiter.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(jupiter.rotate_angle), [0, 1, 0]);
                            drawSphere(jupiter);
                        popMatrix('model');
                    popMatrix('model');

                    // 土星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [saturn.orbit.semi_major - saturn.orbit.perihelion, 0, 0]);
                        darwOrbit(saturn.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(saturn.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [saturn.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(saturn.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(saturn.rotate_angle), [0, 1, 0]);
                            drawSphere(saturn);

                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(0), [0, 0, 1]);
                            darwRing(saturn.ring);
                        popMatrix('model');

                        
                    popMatrix('model');

                    // 天王星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [uranus.orbit.semi_major - uranus.orbit.perihelion, 0, 0]);
                        darwOrbit(uranus.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(uranus.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [uranus.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(uranus.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(uranus.rotate_angle), [0, 1, 0]);
                            drawSphere(uranus);
                        popMatrix('model');
                    popMatrix('model');

                    // 海王星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [neptune.orbit.semi_major - neptune.orbit.perihelion, 0, 0]);
                        darwOrbit(neptune.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(neptune.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [neptune.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(neptune.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(neptune.rotate_angle), [0, 1, 0]);
                            drawSphere(neptune);
                        popMatrix('model');
                    popMatrix('model');

                    // 冥王星
                    pushMatrix('model');
                        mat4.translate(topMatrix('model'), topMatrix('model'), [pluto.orbit.semi_major - pluto.orbit.perihelion, 0, 0]);
                        darwOrbit(pluto.orbit);
                    popMatrix('model');
                    pushMatrix('model');
                        mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(pluto.orbital_angle), [0, 1, 0]);
                        mat4.translate(topMatrix('model'), topMatrix('model'), [pluto.AU, 0, 0]);
                        pushMatrix('model');
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(pluto.obliquity), [-1, 0, 0]);
                            mat4.rotate(topMatrix('model'), topMatrix('model'), deg2Rad(pluto.rotate_angle), [0, 1, 0]);
                            drawSphere(pluto);
                        popMatrix('model');
                    popMatrix('model');
                popMatrix('model');
            }

            function resize(gl) {
				gl.canvas.width = window.innerWidth;
				gl.canvas.height = window.innerHeight;
                gl.viewportWidth = gl.canvas.width;
                gl.viewportHeight = gl.canvas.height;
            }

            function webGLStart() {
                let canvas = $('#testing')[0];
                initGL(canvas);
                initShaders();
                initBuffers();

                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                document.onkeydown = handleKeyDown;
                document.onkeyup = handleKeyUp;

                // document.onmousemove = handleMouseMove;
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
                canvas.onclick = function() {
                    canvas.requestPointerLock();
                }
                document.addEventListener('pointerlockchange', lockChangeAlert, false);
                document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
                updateCameraStatus();

                resize(gl);
		        window.addEventListener('resize', function() {
                    resize(gl);
                });

                // cube.texture = loadTexture("/WebGL/images/TextureCube/sand.jpg");
                cube.texture = loadCubeMap("/WebGL/images/CubeMap/universe", "png");
                // sphere.texture = loadTexture("/WebGL/images/SolarSystem/earth_daytime.jpg");
                // space.texture = loadTexture("/WebGL/images/SolarSystem/astronomersu.jpg");

                sun.texture = loadTexture("/WebGL/images/SolarSystem/sun.jpg");
                mercury.texture = loadTexture("/WebGL/images/SolarSystem/mercury.jpg");
                venus.texture = loadTexture("/WebGL/images/SolarSystem/venus.jpg");
                venus.cloud.texture = loadTexture("/WebGL/images/SolarSystem/venus_atmosphere.jpg");
                
                earth.texture = loadTexture("/WebGL/images/SolarSystem/earth/earth_daytime.jpg");
                earth.specular_texture = loadTexture("/WebGL/images/SolarSystem/earth/2k_earth_specular_map.tif");
                earth.bump_texture = loadTexture("/WebGL/images/SolarSystem/earth/2k_earth_normal_map.tif");
                earth.depth_texture = loadTexture("/WebGL/images/SolarSystem/earth/earth_depth.png");
                earth.emission_texture = loadTexture("/WebGL/images/SolarSystem/earth/earth_nightmap.jpg");
                earth.cloud.texture = loadTexture("/WebGL/images/SolarSystem/earth_clouds.png");
                
                moon.texture = loadTexture("/WebGL/images/SolarSystem/moon.jpg");
                mars.texture = loadTexture("/WebGL/images/SolarSystem/mars.jpg");
                jupiter.texture = loadTexture("/WebGL/images/SolarSystem/jupiter.jpg");
                saturn.texture = loadTexture("/WebGL/images/SolarSystem/saturn.jpg");
                saturn.ring.texture = loadTexture("/WebGL/images/SolarSystem/saturn-rings.png");
                uranus.texture = loadTexture("/WebGL/images/SolarSystem/uranus.jpg");
                neptune.texture = loadTexture("/WebGL/images/SolarSystem/neptune.jpg");
                pluto.texture = loadTexture("/WebGL/images/SolarSystem/pluto.jpg");

                tick();
            }

            function lockChangeAlert() {
                let canvas = $('#testing')[0];
                if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
                    console.log('The pointer lock status is now locked');
                    document.addEventListener("mousemove", handleMouseMove, false);
                    document.addEventListener("mousedown", handleMouseDown, false);
                } else {
                    console.log('The pointer lock status is now unlocked');
                    document.removeEventListener("mousemove", handleMouseMove, false);
                    document.removeEventListener("mousedown", handleMouseDown, false);
                }
            }

            function updateCameraStatus() {
                $('#positionX').text(Math.round(camera.position[0]));
                $('#positionY').text(Math.round(camera.position[1]));
                $('#positionZ').text(Math.round(camera.position[2]));
                $('#directionX').text(Math.round(camera.direction[0] * 1000) / 1000);
                $('#directionY').text(Math.round(camera.direction[1] * 1000) / 1000);
                $('#directionZ').text(Math.round(camera.direction[2] * 1000) / 1000);
                $('#rightX').text(Math.round(camera.right[0] * 1000) / 1000);
                $('#rightY').text(Math.round(camera.right[1] * 1000) / 1000);
                $('#rightZ').text(Math.round(camera.right[2] * 1000) / 1000);
                $('#upX').text(Math.round(camera.up[0] * 1000) / 1000);
                $('#upY').text(Math.round(camera.up[1] * 1000) / 1000);
                $('#upZ').text(Math.round(camera.up[2] * 1000) / 1000);
                $('#facing').text('');
                if(Math.round(camera.direction[2]) == 1) {
                    $('#facing').text('South');
                }else if(Math.round(camera.direction[2]) == -1) {
                    $('#facing').text('North');
                }else {
                    if(Math.round(camera.direction[0]) == 1){
                        $('#facing').text('East');
                    }else {
                        $('#facing').text('West');
                    }
                }

                $('#years').text(earth.count.orbit);
                $('#months').text(moon.count.orbit);
                $('#days').text(earth.count.rotate);
                $('#speed').text(earth.speed);
                $('#yaw').text(Math.round(camera.yaw * 10) / 10);
                $('#pitch').text(Math.round(camera.pitch * 10) / 10);

                $('#lightingModel').text(lightingModels[currentLighting].name);
            }

            $('.switch-box').click(function(e){
                if(isInfoPlaneOn){
                    $(this).text('On');
                    isInfoPlaneOn = false;
                    $(this).parent().addClass('hide');
                }else{
                    $(this).text('Off');
                    isInfoPlaneOn = true;
                    $(this).parent().removeClass('hide');
                }
            });

            webGLStart();
        });
    </script>
</body>
</html>